package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"../utils"
)

func main() {
	dir := "files/keys"
	fs, _ := ioutil.ReadDir(dir)
	out, _ := os.Create("shell/keys.go")
	out.Write([]byte("package shell \n\n// autogenerated - do not modify\n\nconst (\n"))
	for _, f := range fs {
		log.Printf("Processing %s\n", f.Name())
		out.Write([]byte(strings.ReplaceAll(f.Name(), ".", "_") + " = `"))
		f, _ := os.Open(fmt.Sprintf("%s/%s", dir, f.Name()))
		io.Copy(out, f)
		out.Write([]byte("`\n"))
	}
	out.Write([]byte(")\n"))

	dir = "files/sc"
	fs, _ = ioutil.ReadDir(dir)
	out, _ = os.Create("meter/sc.go")
	out.Write([]byte("package meter \n\n// autogenerated - do not modify\n\nconst (\n"))
	// static key for shellcode encryption on compile time (just some evasion, if someone has the binary he can decrypt it easily)
	for _, f := range fs {
		log.Printf("Processing %s\n", f.Name())
		out.Write([]byte(f.Name() + " = \""))
		data, err := ioutil.ReadFile(fmt.Sprintf("%s/%s", dir, f.Name()))
		if err != nil {
			log.Fatal(err)
		}
		enc, err := utils.Encrypt(utils.AESKEY, data)
		if err != nil {
			log.Fatal(err)
		}
		hexenc := ""
		for _, c := range enc {
			hexenc += fmt.Sprintf("%02x", c)
		}
		out.Write([]byte(hexenc))
		out.Write([]byte("\"\n"))
	}
	out.Write([]byte(")\n"))

}
